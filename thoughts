
// ... parser ...
[Parser]
-> templates
-> mainProcessId
-> processes


// ... during parsing a template ...

processId = createProcess( template )
	createProcess
		-> pulls a fresh id
		-> creates process instance
		-> initialize template with template
		-> initialize markup with userMarkup

rule = buildRule( processId, rawRule )
	-> extract rule parts
		-> request / key / options string
			-> options are extracted by buildOptions( optionsString );
				buildOptions
					-> extract option and return an assossiated object
	-> initialize options with the base option set
		-> when defined apply additional request option set
	-> overwrite it with a given option set of the user

query = buildQuery( rule, processId );

-> pass process to the 

// contains information about the current processing template
[Process]
-> processId
-> template
-> markup
-> currentQuery

// contains information about a rule within the template
[Rule]
-> rawRule
-> request
-> key
-> options

// contains rule and some extra information about the current processing rule
// this object is passed to the provided callback function
[Query] : [Rule]
-> processId
-> parentProcessId // not implemented
-> value
-> isPostQuery
// rawRule
// request
// key
// options


### disabling option definition in the rule
When i first had the idea implementing that feature it was pretty nice.
After some time, the implementation worked. It was the same as if you defined your own options
in the markup but in the rule itself. And this is where the idea started to crack.

Does it make any sense to implement a duplicated functionality with a higher failure rate
than in the markup? A property 'options' especially set to define options?
No. Now i dont think so and there is no reason to keep it. I removed it.

Having two actually identical functionalites mostly result in confusing users.
You defined one value in the markup and another one inline in the rule.
Afterwards you check the output and strangely question yourself "what the hell?".

The inline options have a lower priority than the ones in the markup (when defined).
The reason is because the markup is coded and not interpreted by the framework.
Values in the rule are extracted as a string and checked and maybe used by a command.
That might cause some problems when it comes to check for false or true?
Of course, you can convert types but you should avoid it when you want specific result.

In short: The possibility to define option in the rule inline is reasonless
and may result in undefined errors. So, just got rid of it.


